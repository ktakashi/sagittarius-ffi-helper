#!/bin/env sagittarius
;; -*- mode:scheme; coding:utf-8; -*-

#!read-macro=char-set
#!read-macro=sagittarius/regex
(import (rnrs)
	(srfi :13)
	(srfi :14)
	(srfi :26)
	(srfi :39)
	(util file)
	(sagittarius control)
	(sagittarius object)
	(sagittarius regex)
	(parser)
	(preprocess)
	(prefix (parser c) c:)
	(prefix (preprocess c) c:)
	(getopt)
	(match)
	(text parse)
	(pp))

(define *converion-type* (make-parameter #f))
(define *shared-object* (make-parameter #f))
(define *typedefs*      (make-parameter #f))
(define *generated*      (make-parameter #f))
(define preprocessor (make-preprocessor 'c))
(define parser (make-parser 'c))

(define-constant +generated+ "generated")

;; MSVC supports weird annotation
;; and some header is smart enough to detect own platform so that
;; sometime workaround for this won't work. so define it.
(define predefined
  `(("__stdcall"           . "")
    ("__in"                . "")
    ("__out"               . "")
    ("__in_opt"            . "")
    ("__out_opt"           . "")
    ("__inout_opt"         . "")
    ("__deref_out"         . "")
    ("__deref_opt_out"     . "")
    ("__deref_out_opt"     . "")
    ("__in_ecount"         . (("x") ""))
    ("__out_ecount"        . (("x") ""))
    ("__inout_ecount"      . (("x") ""))
    ("__in_ecount_opt"     . (("x") ""))
    ("__out_ecount_opt"    . (("x") ""))
    ("__inout_ecount_opt"  . (("x") ""))
    ("__in_bcount"         . (("x") ""))
    ("__out_bcount"        . (("x") ""))
    ("__inout_bcount"      . (("x") ""))
    ("__in_bcount_opt"     . (("x") ""))
    ("__out_bcount_opt"    . (("x") ""))
    ("__inout_bcount_opt"  . (("x") ""))
    ("__out_xcount"        . (("x") ""))))

(define (generate-libraries macros defs output)
  (define (%->scheme-name name type)
    (define (camel->snake name)
      (call-with-string-output-port
       (lambda (out)
	 (let ((len (string-length name)))
	   (let loop ((i 0))
	     (unless (= i len)
	       (let ((c (string-ref name i)))
		 (cond ((char-upper-case? c)
			(when (and (> i 0)
				   (char-lower-case? (string-ref name (- i 1))))
			  (put-char out #\_))
			(put-char out (char-downcase c))
			(loop (+ i 1)))
		       (else (put-char out c) (loop (+ i 1)))))))))))
    (let ((name (if (memq 'snake type) (camel->snake name) name)))
      (if (memq 'under type)
	  (regex-replace-all #/_/  name "-")
	  name)))
  (define (->scheme-name name)
    (case (*converion-type*)
      ((scheme) (%->scheme-name name '(snake under)))
      ;; camel -> snake
      ((snake)  (%->scheme-name name '(snake)))
      ;; _ -> -
      ((under)  (%->scheme-name name '(under)))
      ;; no conversion
      ((none)   name)
      (else => (^x (error '->scheme-name "unsupported type" x)))))
  (define (symbol->scheme-name name)
    (string->symbol (->scheme-name (symbol->string name))))
  ;; will be used in typedef as well
  (define (resolve-op op e1 e2)
    (and (integer? e1)
	 (integer? e2)
	 (case op
	   ((+) (+ e1 e2))
	   ((-) (- e1 e2))
	   ((*) (* e1 e2))
	   ((/) (div e1 e2))
	   ((%) (mod e1 e2))
	   ((|\||) (bitwise-ior e1 e2))
	   ((&) (bitwise-and e1 e2))
	   ((|\|\||) (if (zero? (+ e1 e2)) 0 1))
	   ((&&)     (if (or (zero? e1) (zero? e2)) 0 1)))))
  (define (read-from-string s) (read (open-string-input-port s)))
  (define (constants macros)
    (define (read-expr s) 
      (define (cs-pred cs) (lambda (c) (char-set-contains? cs c)))
      (define id-set #[0-9a-zA-Z_])
      (define others (char-set-complement id-set))
      (define (next-char in)
	(unless (eof-object? (peek-char in))
	  (skip-while char-whitespace? in))
	(peek-char in))
      ;; it must start with identifier/number op so on..
      ;; but we parse a bit more flexible way
      (let ((in (open-string-input-port s)))
	(let loop ((c (next-char in)) (r '())
		   (nest 0))
	  (cond ((eof-object? c) r)
		((char-set-contains? id-set c)
		 (let ((token (next-token-of (cs-pred id-set) in)))
		   (loop (next-char in) `(,@r ,token) nest)))
		((char=? c #\()
		 (get-char in)
		 (let ((e (loop (next-char in) '() (+ nest 1))))
		   (loop (next-char in) `(,@r ,(list e)) nest)))
		((char=? c #\))
		 (get-char in)
		 (if (zero? nest) r (loop (next-char in) r (- nest 1))))
		;; we don't handle string for now
		((char=? c #\") #f)
		((memv c '(#\+ #\- #\* #\/ #\%))
		 (get-char in)
		 (case (peek-char in)
		   ;; most likely unary expression, ignore
		   ((#\= #\+ #\- #\* #\/ #\%) #f)
		   (else 
		    (loop (next-char in) 
			  `(,@r ,(string->symbol (string c)))
			  nest))))
		((memv c '(#\| #\&))
		 (get-char in)
		 (case (peek-char in)
		   ;; lazy check
		   ((#\| #\&) =>
		    (lambda (nc) 
		      (get-char in)
		      (loop (next-char in)
			    `(,@r ,(string->symbol (string c nc)))
			    nest)))
		   (else
		    => (lambda (nc)
			 (if (or (char-set-contains? id-set nc)
				 (char-whitespace? nc))
			     (loop (next-char in) 
				   `(,@r ,(string->symbol (string c)))
				   nest)
			     ;; |= or so ignore
			     #f)))))
		;; do we know this?
		(else 
		 (format (current-error-port) "unknown operator ~a, in ~a~%" 
			 c s)
		 #f)))))
    (define (try-parse v)
      (define (parse-rec v)	
	(let loop ((expr v))
	  (cond ((null? expr) 0)
		((and (pair? expr) (null? (cdr expr)))
		 (loop (car expr)))
		((pair? expr)
		 (resolve-op (cadr expr)
			     (loop (car expr))
			     (loop (cddr expr))))
		((string? expr)
		 (or (and-let* ((n (c:maybe-c-number expr))
				( (not (eq? expr n)) ))
		       n)
		     (and-let* ((v (assoc expr macros))
				( (integer? (cdr v)) ))
		       (cdr v))))
		(else #f))))
      (if (string? v)
	  (if (not (string-null? v))
	      (let ((e (read-expr v)))
		(if e (parse-rec e) v))
	      #f)
	  v))
    (define (gen-define-constant m)
      (let ((name (car m))
	    (v    (try-parse (cdr m))))
	(if v
	    `(define-constant ,(string->symbol 
				(string-append "+" (->scheme-name name) "+"))
	       ,v)
	    #f)))
    ;; for now we don't convert C macro to Scheme macro
    (let ((macros (filter (lambda (m) (not (pair? (cdr m)))) macros)))
      ;; at sorting by name would make a bit organised. (i hope)
      (filter-map gen-define-constant 
		  (list-sort (^(a b) (string<? (car a) (car b))) macros))))
  ;; use as set
  (define exports (make-eq-hashtable))
  (define (typedef&structs defs)
    (define counter `((union . 0) (struct . 0)))
    (define anon-prefix "@anon-")
    (define (resolve-ops expr)
      (let loop ((expr expr))
	(cond ((null? expr) 0)
	      ((and (pair? expr) (null? (cdr expr))) (car expr))
	      ((pair? expr)
	       (resolve-op (cadr expr)
			   (car expr)
			   (resolve-ops (cddr expr))))
	      ((number? expr) expr)
	      (else (error 'resolve-ops "unknown element" expr)))))
    (define (struct-or-union? x) (or (eq? x 'struct) (eq? x 'union)))
    (define (symbol-join types)
      (string->symbol (string-join (map symbol->string types) "-")))
    (define (parse-member member)
      (match member
	(((((? struct-or-union? x) type ignore ...)) (p? name))
	 `(struct ,(symbol->scheme-name type) ,name))
	(((type ...) (pointer? name rest ...))
	 (if (null? rest)
	     (if pointer?
		 `(void* ,name) ;; easy :)
		 `(,(symbol-join type) ,name))
	     ;; array
	     (let ((n (resolve-ops (cadr rest))))
	       (if pointer?
		   `(void* array ,n ,name)
		   `(,(symbol-join type) array ,n ,name)))))
	(_ (error 'parse-member "unknown format" member))))
    ;; TODO find anonymous struct and union
    (define (liftup-anonymous members)
      (define (gen-anonymous-name type)
	(let* ((slot (assq type counter))
	       (name (string->symbol (format "~a~a.~a" anon-prefix 
					     type (cdr slot)))))
	  (set-cdr! slot (+ (cdr slot) 1))
	  name))
      (define (liftup-anonymous member)
	(define (get-name type maybe-name)
	  (if (null? maybe-name) 
	      type
	      (cadar maybe-name)))
	(match member
	  ((((type #f members)) . maybe-name)
	   (let* ((st-type (gen-anonymous-name type))
		  (name (get-name st-type maybe-name)))
	     (values (gen-typedef-struct `(((,type ,st-type ,members)) #f))
		     `(((,type ,st-type ())) (#f ,name)))))
	  (((type ...) ignore ...) (values #f member))))
      (let loop ((members members) (anon '()) (member '()))
	(cond ((null? members)
	       (values (reverse! anon) (reverse! member)))
	      (else
	       (let-values (((a m) (liftup-anonymous (car members))))
		 (loop (cdr members)
		       (if a (cons a anon) anon)
		       (cons m member)))))))
    ;; TODO enum as well
    (define (gen-typedef-struct def)
      (match def
	((('typedef ((? struct-or-union? x) name members)) defnames ...)
	 ;; we make original struct and typedefs
	 ;; def contains anonymous as well so mind it
	 (let ((def (gen-typedef-struct `(((,x ,name ,members)) #f)))
	       (typedefs (gen-typedef-struct `((typedef ,name) ,@defnames))))
	   (if (null? typedefs)
	       `(begin ,@(cdr def))
	       `(begin ,@(cdr def) ,typedefs))))
	;; later
	((('typedef ('enum name members)) (((p? defname) . ignore) rest ...))
	 (hashtable-set! exports defname #t)
	 (let ((vals (gen-typedef-struct `(((enum ,name ,members)) #f))))
	   `(begin
	      ,vals
	      (define-c-typedef int ,defname))))
	((('typedef name ...) (((pointer? defname) . ignore) rest ...))
	 (let ((name (symbol-join name)))
	   (cond ((eq? defname name) '())
		 (else
		  (hashtable-set! exports defname #t)
		  `(define-c-typedef ,name 
		     ,(if pointer? `(* ,defname) defname))))))
	(((((? struct-or-union? x) name members)) rest ...)
	 (let-values (((anonymous members) (liftup-anonymous members)))
	   (unless (string-prefix? anon-prefix (symbol->string name))
	     (hashtable-set! exports name #t))
	   `(begin
	      ,@anonymous
	      (,(string->symbol (format "define-c-~a" x))
	       ,name
	       ,@(map parse-member members)))))
	(((('enum name members)) rest ...)
	 (when name (hashtable-set! exports name #t))
	 (let loop ((members members) (val 0) (r '()))
	   (define (genconst name v)
	     (let1 name (string->symbol
			 (format "+~a+" (symbol->scheme-name name)))
	       (hashtable-set! exports name #t)
	       `(define-constant ,name ,v)))
	   (if (null? members) 
	       `(begin ,@(reverse! r))
	       (match (car members)
		 ((name . v)
		  (loop (cdr members)
			(+ v 1)
			(cons (genconst name v) r)))
		 (name (loop (cdr members)
			     (+ val 1) 
			     (cons (genconst name val) r)))))))
	;; something else
	(_ #;(pp def) #f)))
    (define (gen-comamnd-typedef typedefs)
      (let1 alist (filter-map (lambda (s) (and (symbol? (cdr s)) s))
			      (hashtable->alist typedefs))
	(map (lambda (s) `(define-c-typedef ,(cdr s) ,(car s))) alist)))
    (append (gen-comamnd-typedef (*typedefs*))
	    (filter-map gen-typedef-struct defs)))

  (define (functions defs)
    (define (gen-define def)
      (define (arg-type type)
	(match type
	  ;; for void, we need special treatment
	  (((type)) (if (eq? 'void type) #f type))
	  (((type) pointer? name)
	   (if pointer? 'void* type))))
      (match def
	((((? symbol? ret)) (((p? name arg-types ...) . ignore)))
	 (let ((sname (symbol->scheme-name name)))
	   `(define ,sname 
	      ;; we can't make sure if it's there or not during
	      ;; the generation, so just make it #f
	      (guard (e (else #f))
		(c-function shared-lib ,(if p? 'void* ret)
			    ,name 
			    ;; in case of (void)
			    ;; FIXME even though (void, int)
			    ;; is invalid this emits (int)
			    ,(filter-map arg-type arg-types))))))
	(_ #;(pp def) #f)))

    (filter-map gen-define defs))
  (let ((consts (constants macros))
	(types  (typedef&structs  defs))
	(funcs  (functions defs))
	(top-library (read-from-string output)))
    (define (->path e)
      (call-with-string-output-port
       (lambda (out)
	 (dolist (c (string->list (->string e)))
	   (case c
	     ((#\\ #\/ #\: #\* #\? #\" #\< #\> #\|)
	      ;; convert to hex
	      (format out "%~x" (char->integer c)))
	     (else (put-char out c)))))))
    (define (safe-delete file)
      (print "Generating " file)
      (when (file-exists? file) (delete-file file)))
    (define (emit out name export import defs)
      (define (emit-clause name values)
	(format out "    (~a~%" name)
	(for-each (cut format out "      ~s~%" <>) values)
	(format out "     )~%"))
      (put-string out ";; -*- mode:scheme; coding:utf-8; -*-") (newline out)
      (put-string out ";; Generated by genbind") (newline out)
      (format out     ";; ~a~%" (string-join (command-line)))
      (format out "(library ~a~%" name)
      (emit-clause 'export export)
      (emit-clause 'import import)
      (for-each (cut format out "  ~s~%" <>) defs)
      (put-char out #\)) (newline out)
      name)
    (define (add-shared-object funcs)
      (let1 location (call-with-input-file (*shared-object*) read)
	(cons `(define shared-lib (open-shared-library ,location))
	      funcs)))

    ;; now we need to make this as a library
    ;; create directory
    (let ((base-path (apply build-path* (*generated*) (map ->path top-library))))
      (define (generate-file name export import defs :optional (top? #f))
	(let1 file (if top?
		       (string-append base-path ".scm")
		       (build-path base-path (format "~a.scm" name)))
	  (safe-delete file)
	  (call-with-output-file file
	    (cut emit <> 
		 (if top? top-library (append top-library (list name)))
		 export import defs))))
      (unless (file-exists? base-path) (create-directory* base-path))
      (let* ((c (generate-file 'constants (map cadr consts) 
			       '((only (sagittarius) define-constant)) consts))
	     (t (generate-file 'types (hashtable-keys-list exports)
			       '((rnrs)
				 (only (sagittarius) define-constant)
				 (sagittarius ffi)) types))
	     (a (generate-file 'apis (map cadr funcs) 
			       `((rnrs) (sagittarius) (sagittarius ffi)
				 ,t)
			      (add-shared-object funcs))))
	(generate-file #f '(:all) `(,c ,t ,a) '() #t)))))

(define (usage)
  (print "genbind [Options] file")
  (print "  Options:")
  (print "   -o,--output     Top most output library name.")
  (print "      This creates maximum 4 librarys with following structure")
  (print "        - output")
  (print "            - constant")
  (print "            - types")
  (print "            - functions")
  (print "      Top most output library must be specified. e.g. (ffi name)")
  (print "   -s,--shared     Shared object location definition file.")
  (exit -1))

(define (main args)
  (define (parse-def define)
    (cond ((#/(\w+?)=(.+)/ define) =>
	   (lambda (m) (cons (m 1) (m 2))))
	  (else (cons define ""))))
  (define (do-parser in typedefs)
    (let loop ((r '()))
      (if (eof-object? (peek-char in))
	  (reverse! r)
	  (let ((v (parser in typedefs)))
	    (pp v)
	    (loop (cons v r))))))
  (define (->hashtable types)
    (define (parse-type t)
      (cond ((#/([^=]+)=(.+)/ t)
	     => (lambda (m) (values (string->symbol (m 1))
				    (string->symbol (m 2)))))
	    (else (values (string->symbol t) #t))))
    (let ((tab (make-eq-hashtable)))
      (dolist (t types)
	(let-values (((name value) (parse-type t)))
	  (hashtable-set! tab name value)))
      tab))
  (with-args (cdr args)
      ((includes (#\I "include") * '())
       (defines  (#\D "define")  * '())
       (types    (#\t "typedef") * '())
       (expand   (#\E "expand")  #f #f)
       (output   (#\o "output")  #t (usage))
       (convert  (#\c "convert") #t "scheme")
       (dump     (#\d "dump")    #t #f)
       (dest     (#\O "output-dir") #t +generated+)
       (shared-file (#\s "shared") #t (usage))
       . rest)
    (when (null? rest) (usage))
    (unless (file-exists? shared-file) (usage))
    (let-values (((dir base ext) (decompose-path (car rest)))
		 ((out path) (make-temporary-file)))
      (let ((out (transcoded-port out (native-transcoder))))
	(parameterize ((*includes* includes)
		       (*current-path* dir)
		       (c:*definitions* (append predefined
						(map parse-def defines)))
		       (*converion-type* (string->symbol convert))
		       (*shared-object* shared-file)
		       ;; keep intace for later
		       (*typedefs* (->hashtable types))
		       (*generated* dest))
	  (unwind-protect
	      (let ((macros (call-with-input-file (car rest)
			      (cut preprocessor <> out)))
		    (typedefs (->hashtable types)))
		(flush-output-port out)
		(let ((defs (call-with-input-file path 
			      (cut parser <> typedefs))))
		  (when dump
		    (when (file-exists? dump) (delete-file dump))
		    (call-with-output-file dump (cut pp defs <>)))
		  (generate-libraries macros defs output)))
	    (close-output-port out)
	    (if expand 
		(rename-file path (string-append base "." ext))
		(delete-file path))
	    ))))))
