#!/bin/env sagittarius
;; -*- mode:scheme; coding:utf-8; -*-

#!read-macro=sagittarius/regex
(import (rnrs)
	(srfi :26)
	(srfi :39)
	(util file)
	(sagittarius control)
	(sagittarius regex)
	(parser)
	(preprocess)
	(prefix (parser c) c:)
	(prefix (preprocess c) c:)
	(getopt)
	(match)
	(pp))

(define preprocessor (make-preprocessor 'c))
(define parser (make-parser 'c))

;; MSVC supports weird annotation
;; and some header is smart enough to detect own platform so that
;; sometime workaround for this won't work. so define it.
(define predefined
  `(("__stdcall"           . "")
    ("__in"                . "")
    ("__out"               . "")
    ("__in_opt"            . "")
    ("__out_opt"           . "")
    ("__inout_opt"         . "")
    ("__deref_out"         . "")
    ("__deref_opt_out"     . "")
    ("__deref_out_opt"     . "")
    ("__in_ecount"         . (("x") ""))
    ("__out_ecount"        . (("x") ""))
    ("__inout_ecount"      . (("x") ""))
    ("__in_ecount_opt"     . (("x") ""))
    ("__out_ecount_opt"    . (("x") ""))
    ("__inout_ecount_opt"  . (("x") ""))
    ("__in_bcount"         . (("x") ""))
    ("__out_bcount"        . (("x") ""))
    ("__inout_bcount"      . (("x") ""))
    ("__in_bcount_opt"     . (("x") ""))
    ("__out_bcount_opt"    . (("x") ""))
    ("__inout_bcount_opt"  . (("x") ""))
    ("__out_xcount"        . (("x") ""))))


(define (generate-libraries macros defs output)
  (define (constants macros)
    ;; for now we don't convert C macro to Scheme macro
    (let ((macros (filter (lambda (m) (not (pair? cdr m))) macros)))
      (pp macros)))
  (constants macros)
)


(define (usage)
  (print "genbind [Options] file")
  (print "  Options:")
  (print "   -o,--output     Top most output library name.")
  (print "      This creates maximum 4 librarys with following structure")
  (print "        - output")
  (print "            - constant")
  (print "            - types")
  (print "            - functions")
  (print "      Top most output library must be specified. e.g. (ffi name)")
  (exit -1))

(define (main args)
  (define (parse-def define)
    (cond ((#/(\w+?)=(.+)/ define) =>
	   (lambda (m) (cons (m 1) (m 2))))
	  (else (cons define ""))))
  (define (do-parser in typedefs)
    (let loop ((r '()))
      (if (eof-object? (peek-char in))
	  (reverse! r)
	  (let ((v (parser in typedefs)))
	    (pp v)
	    (loop (cons v r))))))
  (define (->hashtable types)
    (let ((tab (make-eq-hashtable)))
      (for-each (lambda (t) (hashtable-set! tab (string->symbol t) #t)) types)
      tab))
  (with-args (cdr args)
      ((includes (#\I "include") * '())
       (defines  (#\D "define") * '())
       (types    (#\t "typedefs") * '())
       (expand   (#\E "expand") #f #f)
       (output   (#\o "output") #t (usage))
       . rest)
    (when (null? rest) (usage))
    (let-values (((dir base ext) (decompose-path (car rest)))
		 ((out path) (make-temporary-file)))
      (let ((out (transcoded-port out (native-transcoder))))
	(parameterize ((*includes* includes)
		       (*current-path* dir)
		       (c:*definitions* (append predefined
						(map parse-def defines))))
	  (unwind-protect
	      (let ((macros (call-with-input-file (car rest)
			      (cut preprocessor <> out)))
		    (typedefs (->hashtable types)))
		(flush-output-port out)
		(let ((defs (call-with-input-file path 
			      (cut parser <> typedefs))))
		  (generate-libraries macros defs output)))
	    (close-output-port out)
	    (if expand 
		(rename-file path (string-append base "." ext))
		(delete-file path))
	    ))))))
