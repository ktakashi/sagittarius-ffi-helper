#!/bin/env sagittarius
;; -*- mode:scheme; coding:utf-8; -*-

#!read-macro=char-set
#!read-macro=sagittarius/regex
(import (rnrs)
	(srfi :13)
	(srfi :14)
	(srfi :26)
	(srfi :39)
	(util file)
	(sagittarius control)
	(sagittarius regex)
	(parser)
	(preprocess)
	(prefix (parser c) c:)
	(prefix (preprocess c) c:)
	(getopt)
	(match)
	(text parse)
	(pp))

(define preprocessor (make-preprocessor 'c))
(define parser (make-parser 'c))

;; MSVC supports weird annotation
;; and some header is smart enough to detect own platform so that
;; sometime workaround for this won't work. so define it.
(define predefined
  `(("__stdcall"           . "")
    ("__in"                . "")
    ("__out"               . "")
    ("__in_opt"            . "")
    ("__out_opt"           . "")
    ("__inout_opt"         . "")
    ("__deref_out"         . "")
    ("__deref_opt_out"     . "")
    ("__deref_out_opt"     . "")
    ("__in_ecount"         . (("x") ""))
    ("__out_ecount"        . (("x") ""))
    ("__inout_ecount"      . (("x") ""))
    ("__in_ecount_opt"     . (("x") ""))
    ("__out_ecount_opt"    . (("x") ""))
    ("__inout_ecount_opt"  . (("x") ""))
    ("__in_bcount"         . (("x") ""))
    ("__out_bcount"        . (("x") ""))
    ("__inout_bcount"      . (("x") ""))
    ("__in_bcount_opt"     . (("x") ""))
    ("__out_bcount_opt"    . (("x") ""))
    ("__inout_bcount_opt"  . (("x") ""))
    ("__out_xcount"        . (("x") ""))))

(define (generate-libraries macros defs output)
  (define (->scheme-name name)
    (define (camel->snake name)
      (call-with-string-output-port
       (lambda (out)
	 (let ((len (string-length name)))
	   (let loop ((i 0))
	     (unless (= i len)
	       (let ((c (string-ref name i)))
		 (cond ((char-upper-case? c)
			(put-char out (char-downcase c))
			(when (and (< i (- len 1))
				   (char-lower-case? (string-ref name (+ i 1))))
			  (put-char out #\-))
			(loop (+ i 1)))
		       (else (put-char out c) (loop (+ i 1)))))))))))
    (regex-replace-all #/_/ (camel->snake name) "-"))
  (define (constants macros)
    (define (read-from-string s) (read (open-string-input-port s)))
    (define (read-expr s) 
      (define (cs-pred cs) (lambda (c) (char-set-contains? cs c)))
      (define id-set #[0-9a-zA-Z_])
      (define others (char-set-complement id-set))
      (define (next-char in)
	(unless (eof-object? (peek-char in))
	  (skip-while char-whitespace? in))
	(peek-char in))
      ;; it must start with identifier/number op so on..
      ;; but we parse a bit more flexible way
      (let ((in (open-string-input-port s)))
	(let loop ((c (next-char in)) (r '())
		   (nest 0))
	  (cond ((eof-object? c) r)
		((char-set-contains? id-set c)
		 (let ((token (next-token-of (cs-pred id-set) in)))
		   (loop (next-char in) `(,@r ,token) nest)))
		((char=? c #\()
		 (get-char in)
		 (let ((e (loop (next-char in) '() (+ nest 1))))
		   (loop (next-char in) `(,@r ,(list e)) nest)))
		((char=? c #\))
		 (get-char in)
		 (if (zero? nest) r (loop (next-char in) r (- nest 1))))
		;; we don't handle string for now
		((char=? c #\") #f)
		((memv c '(#\+ #\- #\* #\/ #\%))
		 (get-char in)
		 (case (peek-char in)
		   ;; most likely unary expression, ignore
		   ((#\= #\+ #\- #\* #\/ #\%) #f)
		   (else 
		    (loop (next-char in) 
			  `(,@r ,(string->symbol (string c)))
			  nest))))
		((memv c '(#\| #\&))
		 (get-char in)
		 (case (peek-char in)
		   ;; lazy check
		   ((#\| #\&) =>
		    (lambda (nc) 
		      (get-char in)
		      (loop (next-char in)
			    `(,@r ,(string->symbol (string c nc)))
			    nest)))
		   (else
		    => (lambda (nc)
			 (if (or (char-set-contains? id-set nc)
				 (char-whitespace? nc))
			     (loop (next-char in) 
				   `(,@r ,(string->symbol (string c)))
				   nest)
			     ;; |= or so ignore
			     #f)))))
		;; do we know this?
		(else 
		 (format (current-error-port) "unknown operator ~a, in ~a~%" 
			 c s)
		 #f)))))
    (define (try-parse v)
      (define (parse-rec v)
	(define (resolve-op op e1 e2)
	  (or (and (integer? e1)
		   (integer? e2)
		   (case op
		     ((+) (+ e1 e2))
		     ((-) (- e1 e2))
		     ((*) (* e1 e2))
		     ((/) (div e1 e2))
		     ((%) (mod e1 e2))
		     ((|\||) (bitwise-ior e1 e2))
		     ((&) (bitwise-and e1 e2))
		     ((|\|\||) (if (zero? (+ e1 e2)) 0 1))
		     ((&&)     (if (or (zero? e1) (zero? e2)) 0 1))))
	      v))
	(let loop ((expr v))
	  (cond ((null? expr) 0)
		((and (pair? expr) (null? (cdr expr)))
		 (loop (car expr)))
		((pair? expr)
		 (resolve-op (cadr expr)
			     (loop (car expr))
			     (loop (cddr expr))))
		((string? expr)
		 (or (and-let* ((n (c:maybe-c-number expr))
				( (not (eq? expr n)) ))
		       n)
		     (and-let* ((v (assoc expr macros))
				( (integer? (cdr v)) ))
		       (cdr v))))
		(else #f))))
      (if (string? v)
	  (if (not (string-null? v))
	      (let ((e (read-expr v)))
		(if e (parse-rec e) v))
	      #f)
	  v))
    (define (gen-define-constant m)
      (let ((name (car m))
	    (v    (try-parse (cdr m))))
	(if v
	    `(define-constant ,(string->symbol 
				(string-append "+" (->scheme-name name) "+"))
	       ,v)
	    #f)))
    ;; for now we don't convert C macro to Scheme macro
    (let ((macros (filter (lambda (m) (not (pair? (cdr m)))) macros)))
      (filter-map gen-define-constant macros)))
  (pp (constants macros))
)

(define (usage)
  (print "genbind [Options] file")
  (print "  Options:")
  (print "   -o,--output     Top most output library name.")
  (print "      This creates maximum 4 librarys with following structure")
  (print "        - output")
  (print "            - constant")
  (print "            - types")
  (print "            - functions")
  (print "      Top most output library must be specified. e.g. (ffi name)")
  (exit -1))

(define (main args)
  (define (parse-def define)
    (cond ((#/(\w+?)=(.+)/ define) =>
	   (lambda (m) (cons (m 1) (m 2))))
	  (else (cons define ""))))
  (define (do-parser in typedefs)
    (let loop ((r '()))
      (if (eof-object? (peek-char in))
	  (reverse! r)
	  (let ((v (parser in typedefs)))
	    (pp v)
	    (loop (cons v r))))))
  (define (->hashtable types)
    (let ((tab (make-eq-hashtable)))
      (for-each (lambda (t) (hashtable-set! tab (string->symbol t) #t)) types)
      tab))
  (with-args (cdr args)
      ((includes (#\I "include") * '())
       (defines  (#\D "define") * '())
       (types    (#\t "typedefs") * '())
       (expand   (#\E "expand") #f #f)
       (output   (#\o "output") #t (usage))
       . rest)
    (when (null? rest) (usage))
    (let-values (((dir base ext) (decompose-path (car rest)))
		 ((out path) (make-temporary-file)))
      (let ((out (transcoded-port out (native-transcoder))))
	(parameterize ((*includes* includes)
		       (*current-path* dir)
		       (c:*definitions* (append predefined
						(map parse-def defines))))
	  (unwind-protect
	      (let ((macros (call-with-input-file (car rest)
			      (cut preprocessor <> out)))
		    (typedefs (->hashtable types)))
		(flush-output-port out)
		(let ((defs (call-with-input-file path 
			      (cut parser <> typedefs))))
		  (generate-libraries macros defs output)))
	    (close-output-port out)
	    (if expand 
		(rename-file path (string-append base "." ext))
		(delete-file path))
	    ))))))
