#!/bin/env sagittarius
;; -*- mode:scheme; coding:utf-8; -*-

#!read-macro=char-set
#!read-macro=sagittarius/regex
(import (rnrs)
	(srfi :13)
	(srfi :14)
	(srfi :26)
	(srfi :39)
	(util file)
	(sagittarius control)
	(sagittarius regex)
	(parser)
	(preprocess)
	(prefix (parser c) c:)
	(prefix (preprocess c) c:)
	(getopt)
	(match)
	(text parse)
	(pp))

(define *converion-type* (make-parameter #f))
(define preprocessor (make-preprocessor 'c))
(define parser (make-parser 'c))

;; MSVC supports weird annotation
;; and some header is smart enough to detect own platform so that
;; sometime workaround for this won't work. so define it.
(define predefined
  `(("__stdcall"           . "")
    ("__in"                . "")
    ("__out"               . "")
    ("__in_opt"            . "")
    ("__out_opt"           . "")
    ("__inout_opt"         . "")
    ("__deref_out"         . "")
    ("__deref_opt_out"     . "")
    ("__deref_out_opt"     . "")
    ("__in_ecount"         . (("x") ""))
    ("__out_ecount"        . (("x") ""))
    ("__inout_ecount"      . (("x") ""))
    ("__in_ecount_opt"     . (("x") ""))
    ("__out_ecount_opt"    . (("x") ""))
    ("__inout_ecount_opt"  . (("x") ""))
    ("__in_bcount"         . (("x") ""))
    ("__out_bcount"        . (("x") ""))
    ("__inout_bcount"      . (("x") ""))
    ("__in_bcount_opt"     . (("x") ""))
    ("__out_bcount_opt"    . (("x") ""))
    ("__inout_bcount_opt"  . (("x") ""))
    ("__out_xcount"        . (("x") ""))))

(define (generate-libraries macros defs output)
  (define (%->scheme-name name type)
    (define (camel->snake name)
      (call-with-string-output-port
       (lambda (out)
	 (let ((len (string-length name)))
	   (let loop ((i 0))
	     (unless (= i len)
	       (let ((c (string-ref name i)))
		 (cond ((char-upper-case? c)
			(when (and (> i 0)
				   (char-lower-case? (string-ref name (- i 1))))
			  (put-char out #\_))
			(put-char out (char-downcase c))
			(loop (+ i 1)))
		       (else (put-char out c) (loop (+ i 1)))))))))))
    (let ((name (if (memq 'snake type) (camel->snake name) name)))
      (if (memq 'under type)
	  (regex-replace-all #/_/  name "-")
	  name)))
  (define (->scheme-name name)
    (case (*converion-type*)
      ((scheme) (%->scheme-name name '(snake under)))
      ;; camel -> snake
      ((snake)  (%->scheme-name name '(snake)))
      ;; _ -> -
      ((under)  (%->scheme-name name '(under)))
      ;; no conversion
      ((none)   name)
      (else => (^x (error '->scheme-name "unsupported type" x)))))
  (define (symbol->scheme-name name)
    (string->symbol (->scheme-name (symbol->string name))))
  ;; will be used in typedef as well
  (define (resolve-op op e1 e2)
    (or (and (integer? e1)
	     (integer? e2)
	     (case op
	       ((+) (+ e1 e2))
	       ((-) (- e1 e2))
	       ((*) (* e1 e2))
	       ((/) (div e1 e2))
	       ((%) (mod e1 e2))
	       ((|\||) (bitwise-ior e1 e2))
	       ((&) (bitwise-and e1 e2))
	       ((|\|\||) (if (zero? (+ e1 e2)) 0 1))
	       ((&&)     (if (or (zero? e1) (zero? e2)) 0 1))))
	v))
  (define (constants macros)
    (define (read-from-string s) (read (open-string-input-port s)))
    (define (read-expr s) 
      (define (cs-pred cs) (lambda (c) (char-set-contains? cs c)))
      (define id-set #[0-9a-zA-Z_])
      (define others (char-set-complement id-set))
      (define (next-char in)
	(unless (eof-object? (peek-char in))
	  (skip-while char-whitespace? in))
	(peek-char in))
      ;; it must start with identifier/number op so on..
      ;; but we parse a bit more flexible way
      (let ((in (open-string-input-port s)))
	(let loop ((c (next-char in)) (r '())
		   (nest 0))
	  (cond ((eof-object? c) r)
		((char-set-contains? id-set c)
		 (let ((token (next-token-of (cs-pred id-set) in)))
		   (loop (next-char in) `(,@r ,token) nest)))
		((char=? c #\()
		 (get-char in)
		 (let ((e (loop (next-char in) '() (+ nest 1))))
		   (loop (next-char in) `(,@r ,(list e)) nest)))
		((char=? c #\))
		 (get-char in)
		 (if (zero? nest) r (loop (next-char in) r (- nest 1))))
		;; we don't handle string for now
		((char=? c #\") #f)
		((memv c '(#\+ #\- #\* #\/ #\%))
		 (get-char in)
		 (case (peek-char in)
		   ;; most likely unary expression, ignore
		   ((#\= #\+ #\- #\* #\/ #\%) #f)
		   (else 
		    (loop (next-char in) 
			  `(,@r ,(string->symbol (string c)))
			  nest))))
		((memv c '(#\| #\&))
		 (get-char in)
		 (case (peek-char in)
		   ;; lazy check
		   ((#\| #\&) =>
		    (lambda (nc) 
		      (get-char in)
		      (loop (next-char in)
			    `(,@r ,(string->symbol (string c nc)))
			    nest)))
		   (else
		    => (lambda (nc)
			 (if (or (char-set-contains? id-set nc)
				 (char-whitespace? nc))
			     (loop (next-char in) 
				   `(,@r ,(string->symbol (string c)))
				   nest)
			     ;; |= or so ignore
			     #f)))))
		;; do we know this?
		(else 
		 (format (current-error-port) "unknown operator ~a, in ~a~%" 
			 c s)
		 #f)))))
    (define (try-parse v)
      (define (parse-rec v)	
	(let loop ((expr v))
	  (cond ((null? expr) 0)
		((and (pair? expr) (null? (cdr expr)))
		 (loop (car expr)))
		((pair? expr)
		 (resolve-op (cadr expr)
			     (loop (car expr))
			     (loop (cddr expr))))
		((string? expr)
		 (or (and-let* ((n (c:maybe-c-number expr))
				( (not (eq? expr n)) ))
		       n)
		     (and-let* ((v (assoc expr macros))
				( (integer? (cdr v)) ))
		       (cdr v))))
		(else #f))))
      (if (string? v)
	  (if (not (string-null? v))
	      (let ((e (read-expr v)))
		(if e (parse-rec e) v))
	      #f)
	  v))
    (define (gen-define-constant m)
      (let ((name (car m))
	    (v    (try-parse (cdr m))))
	(if v
	    `(define-constant ,(string->symbol 
				(string-append "+" (->scheme-name name) "+"))
	       ,v)
	    #f)))
    ;; for now we don't convert C macro to Scheme macro
    (let ((macros (filter (lambda (m) (not (pair? (cdr m)))) macros)))
      ;; at sorting by name would make a bit organised. (i hope)
      (filter-map gen-define-constant 
		  (list-sort (^(a b) (string<? (car a) (car b))) macros))))

  (define (typedef&structs defs)
    (define counter `((union . 0) (struct . 0)))
    (define (resolve-ops expr)
      (let loop ((expr expr))
	(cond ((null? expr) 0)
	      ((and (pair? expr) (null? (cdr expr))) (car expr))
	      ((pair? expr)
	       (resolve-op (cadr expr)
			   (car expr)
			   (resolve-ops (cddr expr))))
	      ((number? expr) expr)
	      (else (error 'resolve-ops "unknown element" expr)))))
    (define (struct-or-union? x) (or (eq? x 'struct) (eq? x 'union)))
    (define (parse-member member)
      (match member
	(((((? struct-or-union? x) type ignore ...)) (p? name))
	 `(struct ,(symbol->scheme-name type) ,name))
	(((type) (pointer? name rest ...))
	 (if (null? rest)
	     (if pointer?
		 `(void* ,name) ;; easy :)
		 `(,type ,name))
	     ;; array
	     (let ((n (resolve-ops (cadr rest))))
	       (if pointer?
		   `(void* array ,n ,name)
		   `(,type array ,n ,name)))))
	(_ (error 'parse-member "unknown format" member))))
    ;; TODO find anonymous struct and union
    (define (liftup-anonymous members)
      (define (gen-anonymous-name type)
	(let* ((slot (assq type counter))
	       (name (string->symbol (format "anon-~a.~a" type (cdr slot)))))
	  (set-cdr! slot (+ (cdr slot) 1))
	  name))
      (define (liftup-anonymous member)
	(match member
	  ((((type #f members)))
	   (let ((name (gen-anonymous-name type)))
	     (values (gen-typedef-struct `(((,type ,name ,members)) #f))
		     `(((,type ,name ())) (#f ,name)))))
	  (((type) ignore ...) (values #f member))))
      (let loop ((members members) (anon '()) (member '()))
	(cond ((null? members)
	       (values (reverse! anon) (reverse! member)))
	      (else
	       (let-values (((a m) (liftup-anonymous (car members))))
		 (loop (cdr members)
		       (if a (cons a anon) anon)
		       (cons m member)))))))
    (define (gen-typedef-struct def)
      (match def
	((('typedef ('struct name members)) defnames ...)
	 ;; we make original struct and typedefs
	 ;; def contains anonymous as well so mind it
	 (let ((def (gen-typedef-struct `(((struct ,name ,members)) #f))))
	     `(begin
		,@(cdr def)
		,(gen-typedef-struct `((typedef ,(symbol->scheme-name name))
				       ,@defnames)))))
	((('typedef name) (((pointer? defname) . ignore) rest ...))
	 (let ((defname (symbol->scheme-name defname)))
	   `(define-c-typedef ,name ,(if pointer? `(* ,defname) defname))))
	(((((? struct-or-union? x) name members)) rest)
	 (let-values (((anonymous members) (liftup-anonymous members)))
	   `(begin
	      ,@(if (null? anonymous) anonymous (cdr anonymous))
	      (,(string->symbol (format "define-c-~a" x))
	       ,(symbol->scheme-name name)
		,@(map parse-member members)))))
	;; something else
	(_ (pp def) #f)))
    (filter-map gen-typedef-struct defs))
  (print)(print)
  (let ((consts (constants macros))
	(types  (typedef&structs  defs)))
    (pp consts)
    (pp types)))


(define (usage)
  (print "genbind [Options] file")
  (print "  Options:")
  (print "   -o,--output     Top most output library name.")
  (print "      This creates maximum 4 librarys with following structure")
  (print "        - output")
  (print "            - constant")
  (print "            - types")
  (print "            - functions")
  (print "      Top most output library must be specified. e.g. (ffi name)")
  (exit -1))

(define (main args)
  (define (parse-def define)
    (cond ((#/(\w+?)=(.+)/ define) =>
	   (lambda (m) (cons (m 1) (m 2))))
	  (else (cons define ""))))
  (define (do-parser in typedefs)
    (let loop ((r '()))
      (if (eof-object? (peek-char in))
	  (reverse! r)
	  (let ((v (parser in typedefs)))
	    (pp v)
	    (loop (cons v r))))))
  (define (->hashtable types)
    (let ((tab (make-eq-hashtable)))
      (for-each (lambda (t) (hashtable-set! tab (string->symbol t) #t)) types)
      tab))
  (with-args (cdr args)
      ((includes (#\I "include") * '())
       (defines  (#\D "define") * '())
       (types    (#\t "typedefs") * '())
       (expand   (#\E "expand") #f #f)
       (output   (#\o "output") #t (usage))
       (convert  (#\c "convert") #t "scheme")
       . rest)
    (when (null? rest) (usage))
    (let-values (((dir base ext) (decompose-path (car rest)))
		 ((out path) (make-temporary-file)))
      (let ((out (transcoded-port out (native-transcoder))))
	(parameterize ((*includes* includes)
		       (*current-path* dir)
		       (c:*definitions* (append predefined
						(map parse-def defines)))
		       (*converion-type* (string->symbol convert)))
	  (unwind-protect
	      (let ((macros (call-with-input-file (car rest)
			      (cut preprocessor <> out)))
		    (typedefs (->hashtable types)))
		(flush-output-port out)
		(let ((defs (call-with-input-file path 
			      (cut parser <> typedefs))))
		  (generate-libraries macros defs output)))
	    (close-output-port out)
	    (if expand 
		(rename-file path (string-append base "." ext))
		(delete-file path))
	    ))))))
